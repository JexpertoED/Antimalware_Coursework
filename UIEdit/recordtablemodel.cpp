#include "recordtablemodel.h"

RecordTableModel::RecordTableModel(QObject *parent) : QAbstractTableModel(parent) {
}

RecordTableModel::~RecordTableModel() {
}

int RecordTableModel::rowCount(const QModelIndex &parent) const {
    return parent.isValid() ? 0 : records.size();
}

int RecordTableModel::columnCount(const QModelIndex &parent) const {
    return parent.isValid() ? 0 : 6;
}
QVariant RecordTableModel::data(const QModelIndex &index, int role) const {
    if (!index.isValid())
            return QVariant();

    if (index.row() >= records.size() || index.row() < 0)
            return QVariant();

    if (role == Qt::DisplayRole) {
        Record* record = records[index.row()];

        switch (index.column()) {
            case 0:
                return record->virusName;
            case 1:
                return record->signatureLength;
            case 2:
                return record->prefix.toHex();
            case 3:
                return record->signatureHash.toHex();
            case 4:
                return record->offsetBegin;
            case 5:
                return record->offsetEnd;
            default:
                break;
        }
    }


    return QVariant();
}

QVariant RecordTableModel::headerData(int section, Qt::Orientation orientation, int role) const {
    if (role != Qt::DisplayRole)
        return QVariant();

    if (orientation == Qt::Horizontal) {
        switch (section) {
            case 0:
                return "Название";
            case 1:
                return "Длина cигнатуры";
            case 2:
                return "Префикс";
            case 3:
                return "Хэш";
            case 4:
                return "Начальное смещение";
            case 5:
                return "Конечное смещение";
            default:
                break;
        }
    }
    return QVariant();
}

void RecordTableModel::updateRow(int row) {
    const QModelIndex start = QAbstractTableModel::index(row, 0);
    const QModelIndex end = QAbstractTableModel::index(row, 5);
    emit dataChanged(start, end);
}

void RecordTableModel::removeRow(int row) {
    beginRemoveRows(QModelIndex(), row, row);
    records[row]->deleteLater();
    records.remove(row);
    endRemoveRows();
}

void RecordTableModel::clear() {
    if (records.isEmpty())
        return;
    beginRemoveRows(QModelIndex(), 0, records.size() - 1);
    while (!records.isEmpty()) {
        Record *record = records.takeLast();
        record->deleteLater();
    }
    endRemoveRows();
}

void RecordTableModel::appendRecord(Record *record) {
    record->setParent(this);
    beginInsertRows(QModelIndex(), records.size(), records.size());
     //TODO: add unique check
    records.append(record);
    endInsertRows();
}

QVector<Record*>& RecordTableModel::getRecords() {
    return records;
}



bool RecordTableModel::setData(const QModelIndex& index, const QVariant& value, int role) {
    if (role == Qt::EditRole) {
        if (!checkIndex(index))
            return false;
        int i = index.row();
        QByteArray* ba;
        QString s(value.toString());
        switch (index.column()) {
        case 0:
        	    records[i]->virusName = s;
                break;
            case 1:
                records[i]->signatureLength = (value.toInt());
                break;
            case 2:
                records[i]->prefix = value.toByteArray();
                break;
            case 3:
                records[i]->signatureHash = value.toByteArray();
                break;
            case 4:
                records[i]->offsetBegin = value.toInt();
                break;
            case 5:
                records[i]->offsetEnd = value.toInt();
                break;
        }
        emit dataChanged(index, index);
        return true;
    }
    return false;
}

Qt::ItemFlags RecordTableModel::flags(const QModelIndex& index) const {
    return Qt::ItemIsEditable | QAbstractTableModel::flags(index);
}